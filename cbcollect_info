#!/usr/bin/python
# -*- python -*-
import glob
import mmap
import os
import platform
import re
import signal
import socket
import string
import subprocess
import sys
import tempfile
import thread
from threading import Thread
import time
import urllib2
import urlparse

USAGE = """usage: %prog [options] output_file.zip

- Linux/Windows/OSX:
    %prog output_file.zip
    %prog -v output_file.zip"""

QUIET = ""
QUIET_OUTPUT = ""


class StdinReader:
    """Gives erlang the abilty to shutdown down the process by sending
    'shutdown' to STDIN. If the erlang parent process dies cbcollect will exit.
    """
    def __init__(self):

        def _watchStdin():
            """Read from and consume stdin, watching for "exit" - when detected
            terminate the process.
            """
            while True:
                line = sys.stdin.readline()
                if line:
                    line = line.strip()
                    if line == "shutdown":
                        thread.interrupt_main()
                else:
                    # Unable to read line; assume stdin has been broken -
                    # terminate.
                    thread.interrupt_main()

        self._thread = Thread(target=_watchStdin, name='StdinReader')
        self._thread.setDaemon(True)
        self._thread.start()


class TempFile(object):
    unlink = os.unlink
    def __init__(self):
        fd, self.name = tempfile.mkstemp(text=True)
        self.fp = os.fdopen(fd, 'w+')

    def __getattr__(self, name):
        return getattr(self.__dict__['fp'], name)

    def __del__(self):
        try:
            self.fp.close()
        except:
            pass

        self.unlink(self.name)


class PutRequest(urllib2.Request):
    """Subclass of urllib2.Request for HTTP 'PUT' requests."""

    def get_method(self):
        return 'PUT'


class Task(object):
    privileged = False
    no_header = False
    num_samples = 0
    interval = 0
    def __init__(self, description, command, **kwargs):
        self.description = description
        self.command = command
        self.__dict__.update(kwargs)

    def execute(self, fp):
        """Run the task"""
        import subprocess
        use_shell = not isinstance(self.command, list)
        if "literal" in self.__dict__:
            print >> fp, self.literal
            return 0

        if hasattr(self, 'reformat') and self.reformat:
            p = subprocess.Popen(self.command, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE, shell = use_shell)
            print >> fp, p.stdout.read()
        else:
            env = None
            if "addenv" in self.__dict__:
                env = os.environ.copy()
                env.update(self.addenv)
            p = subprocess.Popen(self.command, bufsize=-1, stdout=fp, stderr=fp,
                                 shell = use_shell, env = env)
        return p.wait()

    def will_run(self):
        """Determine if this task will run on this platform."""
        return sys.platform in self.platforms


class TaskRunner(object):
    default_name = "couchbase.log"

    def __init__(self, verbosity=0):
        self.files = {}
        self.tasks = {}
        self.verbosity = verbosity
        self.start_time = time.strftime("%Y%m%d-%H%M%S", time.gmtime())

    def get_file(self, filename):
        if filename in self.files:
            fp = self.files[filename]
        else:
            fp = TempFile()
            self.files[filename] = fp

        return fp

    def header(self, fp, title, subtitle):
        separator = '=' * 78
        print >> fp, separator
        print >> fp, title
        print >> fp, subtitle
        print >> fp, separator
        fp.flush()

    def log_result(self, result):
        if result == 0:
            log_progress("OK\n")
        else:
            log_progress("Exit code %d\n" % result)

    def run(self, task):
        """Run a task with a file descriptor corresponding to its log file"""
        if task.will_run():
            if hasattr(task, 'command_to_print'):
                command_to_print = task.command_to_print
            else:
                command_to_print = task.command

            log_progress("%s (%s) - " % (task.description, command_to_print))
            if task.privileged and os.getuid() != 0:
                log_progress("skipped (needs root privs)\n")
                return

            if hasattr(task, 'log_file'):
                filename = task.log_file
            else:
                filename = self.default_name

            fp = self.get_file(filename)
            if not task.no_header:
                self.header(fp, task.description, command_to_print)
            result = task.execute(fp)
            fp.flush()
            self.log_result(result)
            for i in xrange(2, task.num_samples + 2):
                log_progress("Taking sample %d after %f seconds - " % \
                    (i, task.interval))
                time.sleep(task.interval)
                result = task.execute(fp)
                self.log_result(result)
        elif self.verbosity >= 2:
            log_progress('Skipping "%s" (%s): not for platform %s\n' \
                % (task.description, command_to_print, sys.platform))

    def zip(self, filename, node):
        """Write all our logs to a zipfile"""
        from zipfile import ZipFile, ZIP_DEFLATED
        zf = ZipFile(filename, mode='w', compression=ZIP_DEFLATED)
        try:
            for name, fp in self.files.iteritems():
                fp.close()
                zf.write(fp.name,
                         "cbcollect_info_%s_%s/%s" % (node, self.start_time, name))
        finally:
            zf.close()

    def upload(self, zip_filename, url):
        """Upload the zip file"""
        result = {}
        try:
            f = open(zip_filename)
            mm = mmap.mmap(f.fileno(), os.stat(f.name).st_size, access=mmap.ACCESS_READ)
            opener = urllib2.build_opener(urllib2.HTTPHandler)
            request = PutRequest(url, data=mm)
            request.add_header('Content-Type', 'application/zip')
            res = opener.open(request)
            result['error'] = False
        except urllib2.HTTPError, e:
            result['error'] = True
            result['details'] = ("HTTP error %s received from server: %s"
                                 % (e.code, e.reason))
        except urllib2.URLError, e:
            result['error'] = True
            result['details'] = ("%s. Please check the hostname is correct" +
                                 " and ensure the system has access to" +
                                 " that host.") % e.reason
        mm.close()
        f.close()
        return result


class SolarisTask(Task):
    platforms = ['sunos5', 'solaris']


class LinuxTask(Task):
    platforms = ['linux2']


class WindowsTask(Task):
    platforms = ['win32', 'cygwin']


class MacOSXTask(Task):
    platforms = ['darwin']


class UnixTask(SolarisTask, LinuxTask, MacOSXTask):
    platforms = SolarisTask.platforms + LinuxTask.platforms + MacOSXTask.platforms


class AllOsTask(UnixTask, WindowsTask):
    platforms = UnixTask.platforms + WindowsTask.platforms

def basedir():
    mydir = os.path.dirname(sys.argv[0])
    if mydir == "":
        mydir = "."
    return mydir

def make_os_tasks():
    _tasks = [
        UnixTask("uname", "uname -a"),
        WindowsTask("System information", "systeminfo"),
        WindowsTask("Computer system", "wmic computersystem", reformat=True),
        WindowsTask("Computer OS", "wmic os", reformat=True),
        UnixTask("Directory structure membase - previous versions",
                 "ls -lR /opt/membase /var/membase /var/opt/membase /etc/opt/membase"),
        SolarisTask("Process list snapshot", "prstat -a -c -n 100 -t -v -L 1 10"),
        SolarisTask("Process list", "ps -ef"),
        SolarisTask("Service configuration", "svcs -a"),
        SolarisTask("Swap configuration", "swap -l"),
        SolarisTask("Disk activity", "zpool iostat 1 10"),
        SolarisTask("Disk activity", "iostat -E 1 10"),
        LinuxTask("Process list snapshot", "export TERM=''; top -Hb -n1 || top -H n1"),
        LinuxTask("Process list ", "ps -AwwL -o user,pid,lwp,ppid,nlwp,pcpu,maj_flt,min_flt,pri,nice,vsize,rss,tty,stat,wchan:12,start,bsdtime,command"),
        LinuxTask("Raw /proc/vmstat", "cat /proc/vmstat"),
        LinuxTask("Raw /proc/mounts", "cat /proc/mounts"),
        LinuxTask("Raw /proc/partitions", "cat /proc/partitions"),
        LinuxTask("Raw /proc/diskstats", "cat /proc/diskstats"),
        LinuxTask("Raw /proc/interrupts", "cat /proc/interrupts"),
        LinuxTask("Swap configuration", "free -t"),
        LinuxTask("Swap configuration", "swapon -s"),
        LinuxTask("Kernel modules", "lsmod"),
        LinuxTask("Distro version", "cat /etc/redhat-release"),
        LinuxTask("Distro version", "lsb_release -a"),
        LinuxTask("Installed software", "rpm -qa"),
        # NOTE: AFAIK columns _was_ necessary, but it doesn't appear to be
        # required anymore. I.e. dpkg -l correctly detects stdout as not a
        # tty and stops playing smart on formatting. Lets keep it for few
        # years and then drop, however.
        LinuxTask("Installed software", "COLUMNS=300 dpkg -l"),
        LinuxTask("Extended iostat", "iostat -x -p ALL 1 10 || iostat -x 1 10"),
        LinuxTask("Core dump settings", "find /proc/sys/kernel -type f -name '*core*' -print -exec cat '{}' ';'"),
        UnixTask("sysctl settings", "sysctl -a"),
        LinuxTask("relevant lsof output",
                  "echo moxi memcached vbucketmigrator beam couch_compact godu sigar_port | xargs -n1 pgrep | xargs -n1 -r -- lsof -n -p"),
        LinuxTask("LVM info", "lvdisplay"),
        LinuxTask("LVM info", "vgdisplay"),
        LinuxTask("LVM info", "pvdisplay"),
        MacOSXTask("Process list snapshot", "top -l 1"),
        MacOSXTask("Disk activity", "iostat 1 10"),
        MacOSXTask("Process list ",
                   "ps -Aww -o user,pid,lwp,ppid,nlwp,pcpu,pri,nice,vsize,rss,tty,"
                   "stat,wchan:12,start,bsdtime,command"),
        WindowsTask("Service list", "wmic service where state=\"running\" GET caption, name, state", reformat=True),
        WindowsTask("Process list", "wmic process", reformat=True),
        WindowsTask("Process usage", "tasklist /V /fo list", reformat=True),
        WindowsTask("Swap settings", "wmic pagefile", reformat=True),
        WindowsTask("Disk partition", "wmic partition", reformat=True),
        WindowsTask("Disk volumes", "wmic volume", reformat=True),
        UnixTask("Network configuration", "ifconfig -a", interval=10,
                 num_samples=1),
        LinuxTask("Network configuration", "echo link addr neigh rule route netns | xargs -n1 -- sh -x -c 'ip $1 list' --"),
        WindowsTask("Network configuration", "ipconfig /all", interval=10,
                    num_samples=1),
        UnixTask("Network status", "netstat -anp || netstat -an"),
        WindowsTask("Network status", "netstat -ano"),
        AllOsTask("Network routing table", "netstat -rn"),
        UnixTask("Arp cache", "arp -na"),
        WindowsTask("Arp cache", "arp -a"),
        WindowsTask("Network Interface Controller", "wmic nic", reformat=True),
        WindowsTask("Network Adapter", "wmic nicconfig", reformat=True),
        WindowsTask("Active network connection", "wmic netuse", reformat=True),
        WindowsTask("Protocols", "wmic netprotocol", reformat=True),
        WindowsTask("Cache memory", "wmic memcache", reformat=True),
        WindowsTask("Physical memory", "wmic memphysical", reformat=True),
        WindowsTask("Physical memory chip info", "wmic memorychip", reformat=True),
        WindowsTask("Local storage devices", "wmic logicaldisk", reformat=True),
        UnixTask("Filesystem", "df -ha"),
        UnixTask("System activity reporter", "sar 1 10"),
        UnixTask("System paging activity", "vmstat 1 10"),
        UnixTask("System uptime", "uptime"),
        UnixTask("couchbase user definition", "getent passwd couchbase"),
        UnixTask("couchbase user limits", "su couchbase -c \"ulimit -a\"",
                 privileged=True),
        UnixTask("membase user definition", "getent passwd membase"),
        UnixTask("couchbase user limits", "su couchbase -c \"ulimit -a\"",
                 privileged=True),
        UnixTask("membase user limits", "su membase -c \"ulimit -a\"",
                 privileged=True),
        UnixTask("Interrupt status", "intrstat 1 10"),
        UnixTask("Processor status", "mpstat 1 10"),
        UnixTask("System log", "cat /var/adm/messages"),
        LinuxTask("Raw /proc/uptime", "cat /proc/uptime"),
        LinuxTask("All logs", "tar cz /var/log/syslog* /var/log/dmesg /var/log/messages* /var/log/daemon* /var/log/debug* /var/log/kern.log* 2>/dev/null",
                  log_file="syslog.tar.gz", no_header = True),
        LinuxTask("Relevant proc data", "(pgrep moxi; pgrep beam.smp; pgrep memcached; pgrep couch_compact; pgrep sigar_port ; pgrep godu) | xargs -n1 -- sh -c 'echo $1; cat /proc/$1/status; cat /proc/$1/limits; cat /proc/$1/smaps; cat /proc/$1/numa_maps; cat /proc/$1/task/*/sched; echo' --"),
        LinuxTask("Processes' environment", r"(pgrep beam.smp; pgrep memcached) | xargs -n1 -- sh -c 'echo $1; ( cat /proc/$1/environ | tr \\0 \\n ); echo' --"),
        LinuxTask("NUMA data", "numactl --hardware"),
        LinuxTask("NUMA data", "numactl --show"),
        LinuxTask("NUMA data", "cat /sys/devices/system/node/node*/numastat"),
        UnixTask("Kernel log buffer", "dmesg"),
        LinuxTask("Transparent Huge Pages data", "cat /sys/kernel/mm/transparent_hugepage/enabled"),
        LinuxTask("Transparent Huge Pages data", "cat /sys/kernel/mm/transparent_hugepage/defrag"),
        LinuxTask("Transparent Huge Pages data", "cat /sys/kernel/mm/redhat_transparent_hugepage/enabled"),
        LinuxTask("Transparent Huge Pages data", "cat /sys/kernel/mm/redhat_transparent_hugepage/defrag"),
        LinuxTask("Network statistics", "netstat -s"),
        LinuxTask("Full raw netstat", "cat /proc/net/netstat"),
        LinuxTask("CPU throttling info", "echo /sys/devices/system/cpu/cpu*/thermal_throttle/* | xargs -n1 -- sh -c 'echo $1; cat $1' --"),
        ]

    return _tasks

# stolen from http://rightfootin.blogspot.com/2006/09/more-on-python-flatten.html
def iter_flatten(iterable):
    it = iter(iterable)
    for e in it:
        if isinstance(e, (list, tuple)):
            for f in iter_flatten(e):
                yield f
        else:
            yield e

def flatten(iterable):
    return [e for e in iter_flatten(iterable)]

def read_guts(guts, key):
    if not (key in guts):
        return ""
    return guts[key]

def winquote_path(s):
    return '"'+s.replace("\\\\", "\\").replace('/', "\\")+'"'

# python's split splits empty string to [''] which doesn't make any
# sense. So this function works around that.
def correct_split(string, splitchar):
    rv = string.split(splitchar)
    if rv == ['']:
        rv = []
    return rv

def make_product_task(guts, initargs_path):
    root = os.path.abspath(os.path.join(initargs_path, "..", "..", "..", ".."))
    dbdir = read_guts(guts, "db_dir")
    viewdir = read_guts(guts, "idx_dir")
    _tasks = [
        UnixTask("Directory structure",
                 ["ls", "-lR", root]),
        UnixTask("Database directory structure",
                 ["ls", "-lR", dbdir]),
        UnixTask("Index directory structure",
                 ["ls", "-lR", viewdir]),
        LinuxTask("Database directory filefrag info",
                  ["find", dbdir, "-type", "f", "-exec", "filefrag", "-v", "{}", "+"]),
        LinuxTask("Index directory filefrag info",
                  ["find", viewdir, "-type", "f", "-exec", "filefrag", "-v", "{}", "+"]),
        WindowsTask("Database directory structure",
                    "dir /s " + winquote_path(dbdir)),
        WindowsTask("Index directory structure",
                    "dir /s " + winquote_path(viewdir)),
        UnixTask("Directory structure membase - previous versions",
                 "ls -lR /opt/membase /var/membase /var/opt/membase /etc/opt/membase"),
        WindowsTask("Version file",
                    "type " + winquote_path(basedir()) + "\\..\\VERSION.txt", reformat=True),
        WindowsTask("Manifest file",
                    "type " + winquote_path(basedir()) + "\\..\\manifest.txt", reformat=True),
        WindowsTask("Manifest file",
                    "type " + winquote_path(basedir()) + "\\..\\manifest.xml", reformat=True),
        LinuxTask("Version file", "cat '%s/VERSION.txt'" % root),
        LinuxTask("Manifest file", "cat '%s/manifest.txt'" % root),
        LinuxTask("Manifest file", "cat '%s/manifest.xml'" % root),
        AllOsTask("Couchbase config", "", literal = read_guts(guts, "ns_config")),
        # TODO: just gather those in python
        WindowsTask("Memcached logs",
                    "cd " + winquote_path(read_guts(guts, "memcached_logs_path")) + " && " +
                    "for /f %a IN ('dir /od /b memcached.log.*') do type %a",
                    log_file="memcached.log", reformat=True),
        UnixTask("Memcached logs",
                 ["sh", "-c", 'cd "$1"; for file in $(ls -tr memcached.log.*); do cat \"$file\"; done', "--", read_guts(guts, "memcached_logs_path")],
                 log_file="memcached.log"),
        [WindowsTask("Ini files (%s)" % p,
                     "type " + winquote_path(p),
                     log_file="ini.log", reformat=True)
         for  p in read_guts(guts, "couch_inis").split(";")],
        UnixTask("Ini files",
                 ["sh", "-c", 'for i in "$@"; do echo "file: $i"; cat "$i"; done', "--"] + read_guts(guts, "couch_inis").split(";"),
                 log_file="ini.log"),

        AllOsTask("couchbase diags",
                  ["curl", "-sS",
                   "-u", '%s:%s' % ("@", read_guts(guts, "memcached_pass")),
                   "http://127.0.0.1:%s/diag?noLogs=1" % read_guts(guts, "rest_port")],
                  log_file="diag.log",
                  command_to_print="curl -sS -u %s:***** http://127.0.0.1:%s/diag?noLogs=1" % (read_guts(guts, "rest_user"), read_guts(guts, "rest_port"))),

        [AllOsTask("couchbase logs (%s)" % name, "cbbrowse_logs %s" % name,
                   addenv = [("REPORT_DIR", read_guts(guts, "log_path"))],
                   log_file="ns_server.%s.log" % name)
         for name in ["debug", "info", "error", "couchdb",
                      "xdcr", "xdcr_errors",
                      "views", "mapreduce_errors",
                      "stats", "babysitter", "ssl_proxy", "reports", "xdcr_trace", "access"]],

        [AllOsTask("memcached stats %s" % kind,
                   flatten(["cbstats", "-a", "127.0.0.1:%s" % read_guts(guts, "memcached_port"), kind, "-b", read_guts(guts, "memcached_admin"), "-p", read_guts(guts, "memcached_pass")]),
                   log_file="stats.log")
         for kind in ["all", "checkpoint", "config", "dispatcher",
                      "klog", "kvstore", "kvtimings",
                      "tap", "tapagg", "upr", "upragg", "timings",
                      ["raw", "memory"], ["raw", "allocator"],
                      "prev-vbucket", "vbucket", "vbucket-details",
                      "warmup"]],

        [AllOsTask("ddocs for %s (%s)" % (bucket, path),
                   ["couch_dbdump", path],
                   log_file = "ddocs.log")
         for bucket in set(correct_split(read_guts(guts, "buckets"), ",")) - set(correct_split(read_guts(guts, "memcached_buckets"), ","))
         for path in glob.glob(os.path.join(dbdir, bucket, "master.couch*"))],
        [AllOsTask("replication docs (%s)" % (path),
                   ["couch_dbdump", path],
                   log_file = "ddocs.log")
         for path in glob.glob(os.path.join(dbdir, "_replicator.couch*"))]
        ]

    _tasks = flatten(_tasks)

    return _tasks


def get_server_guts(initargs_path):
    dump_guts_path = os.path.join(basedir(), "dump-guts")
    escript = "escript"
    if platform.system() == 'Windows':
        escript = escript + ".exe"
    extra_args = os.getenv("EXTRA_DUMP_GUTS_ARGS")
    args = [escript, dump_guts_path, "--initargs-path", initargs_path]
    if extra_args:
        args = args + extra_args.split(";")
    log_progress("Checking for server guts in %s..." % initargs_path)
    p = subprocess.Popen(args, stdout = subprocess.PIPE, stderr = subprocess.PIPE )
    output = p.stdout.read()
    log_progress(p.stderr.read())
    p.wait()
    rc = p.returncode
    # print("args: %s gave rc: %d and:\n\n%s\n" % (args, rc, output))
    tokens = output.rstrip("\0").split("\0")
    d = {}
    if len(tokens) > 1:
        for i in xrange(0, len(tokens), 2):
            d[tokens[i]] = tokens[i+1]
    return d

def guess_utility(command):
    if isinstance(command, list):
        command = ' '.join(command)

    if not command:
        return None

    if re.findall(r'[|;&]|\bsh\b|\bsu\b|\bfind\b|\bfor\b', command):
        # something hard to easily understand; let the human decide
        return command
    else:
        return command.split()[0]

def dump_utilities(*args, **kwargs):
    specific_platforms = { SolarisTask : 'Solaris',
                           LinuxTask :  'Linux',
                           WindowsTask : 'Windows',
                           MacOSXTask : 'Mac OS X' }
    platform_utils = dict((name, set()) for name in specific_platforms.values())

    tasks = make_os_tasks() + make_product_task({}, "")

    for task in tasks:
        utility = guess_utility(task.command)
        if utility is None:
            continue

        for (platform, name) in specific_platforms.items():
            if isinstance(task, platform):
                platform_utils[name].add(utility)

    print '''This is an autogenerated, possibly incomplete and flawed list
of utilites used by cbcollect_info'''

    for (name, utilities) in sorted(platform_utils.items(), key=lambda x: x[0]):
        print "\n%s:" % name

        for utility in sorted(utilities):
            print "        - %s" % utility

    sys.exit(0)

def main():
    from optparse import OptionParser

    mydir = os.path.dirname(sys.argv[0])
    #(MB-8239)erl script fails in OSX as it is unable to find COUCHBASE_TOP -ravi
    if platform.system() == 'Darwin':
        os.environ["COUCHBASE_TOP"] = os.path.abspath(os.path.join(mydir, ".."))

    parser = OptionParser(usage=USAGE)
    parser.add_option("-r", dest="root",
                      help="root directory - defaults to %s" % (mydir + "/.."),
                      default=os.path.abspath(os.path.join(mydir, "..")))
    parser.add_option("-v", dest="verbosity", help="increase verbosity level",
                      action="count", default=0)
    parser.add_option("-p", dest="product_only", help="gather only product related information",
                      action="store_true", default=False)
    parser.add_option("-d", action="callback", callback=dump_utilities,
                      help="dump a list of commands that cbcollect_info needs")
    parser.add_option("-u","--upload", dest="upload", action="store_true",
                      default=False, help="Enables upload mode."),
    parser.add_option("-n", "--upload-host", dest="host",
                      help="Mandatory when using --upload. Specifies the host where the logs should be uploaded to")
    parser.add_option("-c", "--customer", dest="customer",
                      help="Mandatory when using --upload. Specifies the customer that uploaded the logs")
    parser.add_option("-t", "--ticket", dest="ticket",
                      help="Optional when --upload is used. Specifies the ticket which the logs are related to")
    parser.add_option("--script", dest="quiet", action="store_true", default=False)

    options, args = parser.parse_args()
    global QUIET
    QUIET = options.quiet
    artifact = ""

    def sigint_handler(signal, frame):
        if QUIET:
            status = 'cancelled'
            details = 'Cancelled during collection'
            if artifact:
                script_output(status, details=details, artifact=artifact)
            else:
                script_output(status, details=details)
        elif artifact:
            log_progress('\nCancelled during upload\nLogs were suscessfully collected: ' + artifact)
        else:
            log_progress('\nCancelled by user Ctrl-c no logs were collected\n')
        sys.exit(1)

    signal.signal(signal.SIGINT, sigint_handler)


    status = ""
    details = ""
    url = ""
    if (options.upload):
        if not options.host:
            status = "badargs"
            details += " --upload-host value."
        if not options.customer:
            status = "badargs"
            details += " --customer value."

        if status == "badargs":
            if QUIET:
                details = "Missing option(s):" + details
                script_output(status, details=details)
                sys.exit(2)
            else:
                parser.error("Missing option(s):" +details)
        url = options.host
        if '//' not in url:
            url = '//' + url

        if not re.search('^[A-Za-z0-9./:]+$', url):
            status = "badargs"
            details += " --upload-host not a valid hostname."
        else:
            (scheme, netloc, path, query, frag) = urlparse.urlsplit(url)

            if not netloc:
                status = "badargs"
                details += " --upload-host not a valid hostname."

            #Ensure that scheme is https
            if scheme:
                if not scheme == "https":
                    status = "badargs"
                    details += " --upload-host only https protocol is supported."
            else:
                scheme = "https"

            if path:
                status= "badargs"
                details += " --upload-host not a valid hostname."

        if not re.search('^[A-Za-z0-9_.-]{1,50}$', options.customer):
            status = "badargs"
            details += " --customer value should only contain the following characters [A-Za-z0-9_.-] with a maximum length of 50."

        if options.ticket and not re.search('^\d{1,7}$', options.ticket):
            status = "badargs"
            details += " --ticket value should be a number with maxium length of 7."

        if status == "badargs":
            if QUIET:
                details = "Bad option(s):" + details
                script_output(status, details=details)
                sys.exit(2)
            else:
                parser.error("Bad option(s):" + details)

        #If all checks pass build the url
        full_url = scheme + "://" + netloc + "/" + options.customer.lower()
        if options.ticket:
            full_url += "/" + options.ticket
    else:
        if options.host:
            status = "badargs"
            details += " --upload-host specified without --upload."
        if options.customer:
            status = "badargs"
            details += " --customer specified without --upload."
        if options.ticket:
            status = "badargs"
            details += " --ticket specified without --upload."
        if status == "badargs":
            if QUIET:
                details = "Missing option:" + details
                script_output(status, details=details)
                sys.exit(2)
            else:
                parser.error("Missing option:" +details)


    if len(args) != 1:
        parser.error("incorrect number of arguments")

    zip_file_path = args[0]
    if zip_file_path[-4:] != '.zip':
        zip_file_path += '.zip'

    zip_dir = os.path.dirname(os.path.abspath(zip_file_path))

    if not os.access(zip_dir, os.W_OK | os.X_OK):
        log_progress("Error: Do not have write access to the directory %s\n" % (zip_dir))
        sys.exit(1)

    erldir = os.path.join(mydir, 'erlang', 'bin')
    if os.name == 'posix':
        path = [mydir,
                '/bin',
                '/sbin',
                '/usr/bin',
                '/usr/sbin',
                '/opt/couchbase/bin',
                erldir,
                os.environ['PATH']]
        os.environ['PATH'] = ':'.join(path)
    elif os.name == 'nt':
      path = [mydir, erldir, os.environ['PATH']]
      os.environ['PATH'] = ';'.join(path)

    runner = TaskRunner(verbosity=options.verbosity)

    if not options.product_only:
        for task in make_os_tasks():
            runner.run(task)

    initargs_variants = [os.path.abspath(os.path.join(options.root, "var", "lib", "couchbase", "initargs")),
                         "/opt/couchbase/var/lib/couchbase/initargs",
                         os.path.expanduser("~/Library/Application Support/Couchbase/var/lib/couchbase/initargs")]

    guts = None
    guts_initargs_path = None

    for initargs_path in initargs_variants:
        d = get_server_guts(initargs_path)
        # print("for initargs: %s got:\n%s" % (initargs_path, d))
        if len(d) > 0:
            guts = d
            guts_initargs_path = initargs_path
            break

    zip_node = ""

    if guts:
        zip_node = read_guts(guts, "node")
        runner.run(
            AllOsTask("product diag header",
                      "",
                      literal = "Found server initargs at %s (%d)" % (guts_initargs_path, len(guts))))

        for task in make_product_task(guts, guts_initargs_path):
            runner.run(task)

    if zip_node.split("@")[-1] == "127.0.0.1":
        zip_node = '@'.join(zip_node.split("@")[:-1] + [find_primary_addr("127.0.0.1")])

    runner.zip(zip_file_path, zip_node)
    zip_filename = os.path.basename(zip_file_path)
    artifact = os.path.abspath(zip_file_path)
    log_progress("Log collected successfully: %s\n" % artifact)
    if not options.upload:
        if QUIET:
            script_output("collected", artifact=artifact)
    else:
        log_progress("Uploading to %s\n" % full_url)
        full_url += "/" + zip_filename
        result = runner.upload(zip_file_path, full_url)
        if not result['error']:
            artifact = full_url
            log_progress("Upload completed\n")
            if QUIET:
                script_output("uploaded", artifact=artifact)
            log_progress("Deleting file %s\n" % zip_file_path )
            os.remove(zip_file_path)
        else:
            log_progress("Upload failed: %s\n" % result['details'])
            if QUIET:
                details = "Failed to upload to %s - %s" % (full_url, result['details'])
                script_output("upload-failed", details=details, artifact=artifact)
            sys.exit(3)
    sys.exit(0)

def find_primary_addr(default = None):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        try:
            s.connect(("8.8.8.8", 56))
            addr, port = s.getsockname()
            return addr
        except socket.error:
            return default
    finally:
        s.close()

def log_progress(message):
    if QUIET:
        global QUIET_OUTPUT
        QUIET_OUTPUT += message
    else:
        print >> sys.stderr, message,

def script_output(status, details = None, artifact = None):
    print "status: " + status
    if artifact:
        print "artifact: " + artifact
    if details:
        print "details: " + details


if __name__ == '__main__':
    reader = StdinReader()
    main()
